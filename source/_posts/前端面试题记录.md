---
title: 前端面试题记录
date: 2021-08-17 09:40:55
tags:
---

## 发现刷面试题也是巩固知识的一个好方法，好记性不如烂笔头，开干

## CSS部分

### 1.垂直居中

高频问题
实现方式分几种
1）基于定位

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #outBox{
      position: relative;
      width: 100%;
      height: 400px;
      background:aqua;
      overflow: auto;
    }
    /* 方法一 必须知道需要居中的box的宽度 */
    #centerBox{
      position: absolute;
      background-color: red;
      width:100px;
      height: 100px;
      top:50%;
      left: 50%;
      margin-top: -50px;
      margin-left: -50px;
    }
    /* 方法二  可以不用知道需要居中的box的宽高，但兼容性不好 */
    #centerBox{
      position: absolute;
      background-color: red;
      top:50%;
      left: 50%;
      transform: translate(-50%,-50%);
    }
    /* 方法三 还是必须需要居中的box有宽高 */
    #centerBox{
      position: absolute;
      background-color: red;
      width:100px;
      height: 100px;
      top:0;
      left: 0;
      bottom: 0;
      right: 0;
      margin: auto;  
    }

  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

2）js

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #outBox{
      position: relative;
      width: 100%;
      height: 400px;
      background:aqua;
      overflow: auto;
    }
    #centerBox{
      position: absolute;
      background-color: red; 
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
<script type="text/javascript">
 window.onload = function(){
    let outBox = document.getElementById("outBox"),
        outBoxH = outBox.offsetHeight,
        outBoxW = outBox.offsetWidth,
        centerBox = document.getElementById("centerBox"),
        centerBoxH =centerBox.offsetHeight,
        centerBoxW = centerBox.offsetWidth;
    centerBox.style.marginLeft = (outBoxW-centerBoxW)/2 + "px";
    centerBox.style.marginTop = (outBoxH-centerBoxH)/2 + "px";
  }
</script>
</html>
</script>
```

3）flex

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #centerBox{
      background-color: red; 
    }
    /*最简单，但也是兼容性问题*/
    #outBox{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 800px;
      height: 400px;
      background:aqua;
    } 
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

### 2.清除浮动

1)触发BFC 即外层div增加属性overflow：hidden

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
      overflow: hidden;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
  </div>
</body>
</html>
```

2)额外增加标签并设置clear:both

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
    .for-clear-float{
      clear: both;
    }
  </style>
</head>
<body>
  <div id="outBox">
    <div id="centerBox">一个三四五</div>
    <div class="for-clear-float"></div>
  </div>
</body>
</html>
```
3)增加after伪元素

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
  /* 方法一 */
    #outBox{
      background-color:aqua;
      width: 400px;
    }
    #centerBox{
      float: left;
      background-color: red;
    }
    .clear{
      *zoom: 1;
    }
    /*加在父div上*/
    .clear:after{
      content: "";
      display: block;
      clear: both;
      height: 0;
      visibility: hidden;
    }

  </style>
</head>
<body>
  <div id="outBox" class="clear">
    <div id="centerBox" >一个三四五</div>
  </div>
</body>
</html>
```

### 3.css3新特性

### 4.介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同

### 待续...

## JS部分

### 1.js数据类型

6大数据类型
五种基本数据类型 Number,Null,Undefined,Boolean,String
一种复杂数据类型 Object
es6 新加入 symbol

### 2.判断数据类型的方法

一.typeof，
优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object
注意！ typeof(null)//object 但typeof 可以检测function

二.instanceof
可进一步区分object为对象还是数组还是函数
优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断

三、Object.prototype.toString.call()

```js
var toString = Object.prototype.toString;
 
console.log(toString.call(1));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('abc'));                  //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(function(){}));           //[object Function]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
```

优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用 

### 3.原生ajax

其实很简单
1.创建xhr(xmlhttprequest)对象
2.请求参数，url ，类型，参数等
3.发送请求
4.监听回调xhr.onreadystatechange,说明请求完成

```js
//步骤一:创建异步对象
var ajax = new XMLHttpRequest();
//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);
//步骤三:发送请求
ajax.send();
//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {   if (ajax.readyState==4 &&ajax.status==200) {
    //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的　　　　console.log(ajax.responseText);//输入相应的内容  　　}
}
```

### 4.null与undefined

null 为 对象压根不存在,undefined 更像是存在但无值

### 5.对象深浅拷贝

#### 浅拷贝

一.object.assign(target,souce)//Object.assign({},{a:1,b:2})

二.手动实现
自己实现也很简单，就一个for循环进行赋值

```javascript
function simpleClone(obj) {
    var result = {};
    for (var i in obj) {
        result[i] = obj[i];
    }
    return result;
}
```

#### 深拷贝

一.json.parse(json.stringfy(obj))
二.手动实现
也没想象中难，就用递归把所有属性都复制下来,但是其中有比较多的细节可以注意

```javascript
function deepClone(obj) {
    var result = {};
    for (var i in obj) {
        if(typeof obj[i] === "object"){
             result[i] = deepClone(obj[i])
        }else{
            result[i] = obj[i];
        }
        
    }
    return result;
}

function deepCopyTwo(obj) {
    let objClone = Array.isArray(obj) ? [] : {};
    if (obj && typeof obj == 'object') {
        for (const key in obj) {
            //判断obj子元素是否为对象，如果是，递归复制
            if (obj[key] && typeof obj[key] === "object") {
                objClone[key] = deepCopyTwo(obj[key]);
            } else {
                //如果不是，简单复制
                objClone[key] = obj[key];
            }
        }
    }
    return objClone;
}

```
